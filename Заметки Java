Для сравнения обьектов используются интерфейсы Compareble & Comporator
    Comparable: // Естественный порядок
        int compareTo(Element element1) - (-1 = меньше, 0 = равны, 1 = больше)
    
    Comparator: // Не естественный порядок
        int compare(Element element1, Element element2) - (таже логика)

        
Generic

    generic-методы - нельзя переопределить или перегрузить из за стирания типов.
    
    <T extends Class & Interface1 & Interface2> - Сначала добавляем класс(только один!). потом перечисляем интерфейсы 
    
    <?> - WildCard (Можно поставить любой класс)
    
    <?> -  любой класс
    <? extends X> - класс X или любой его сабкласс
    <? super Y> - класс Y или любой его суперкласс

    
Collection
    
    ArrayList - (в основе лежит массив) имеет свойства массива, но повышенным  функционалом
        Первоначально имеет какой то размер, когда превышаем этот размер, происходить создание нового массива и перезапись.
        При вставке элемента в середину ArrayList все элементы сдвигаются на шаг(это очень много операций,
        это  связано с тем, что в основе лежит массив)
        Поиск элементов происходит ОЧЕНЬ БЫСТРО
        asList(DataType []) -> List<DataType> - тестно связан с обьектом передаваемым в метод
        subList(int fromIxdex, int toIndex) -> List<E> - создаем представление(int toIndex - не включительно)
        toArray() - создает массив типа Object[]
        toArray(T[] a) -> T[] - создает массив указанного типа
        List.of(E... elements) -> List<E> - создает неизменяемый List (Не может содержать null)
        List.copyOf(Collection <E> c) -> List<E> - Копируют и создает лист(неизменяем)(Не может содержать null)
        
        
    Iterator
        Iterator<DataType> iter = arrayList.iterator();
            while(iter.hasNext()) // проверка есть ли элелемент впереди
            { iter.next(); } // взять следующий элемент
            
    
    LinkedList - (В основе лежит цепочка) 
        Элементы LinkedList - это звенья одной ЦЕПОЧКИ. Эти элементы хранят определенные данные,
        а так же ссылки на предыдущий и следующий элементы
        При создании LinkedList знает ссылки начала(head) и хвоста(tail)
        Каждый элемент знает своих соседей
        Работает связанный список(чтоб найти что то, надо пройти от начала(с конца) до нужного элемента)
        При вставке элемента в середину списка меняются только ссылки у соседей
        (другие элементы это не затрагивает только соседи меняются и нет никакой перезаписи LinkedList, как ArrayList)
        При удалении элемента, обьект удалается из ЦЕПОЧКИ, но при этом обьект все еще существует
        БЫСТРЫЕ операции добавления и удаления
        Как правило, LinkedList следует использовать когда:
            1) Невелико количество операций получения элементов;
            2) Велико количество операций добавления удаления элементов. Особенно если речь идет о элементах в начале коллекций.


    ListIterator
        ListIterator<DataType> iter = list.listIterator();
            hasPrevious() // проверка есть ли преведущий элемент(сзади)
            previous() // взять предыдущий элемент
            
            Listiterator<DataType> listIter = aL.listIterator();
            
                while(listIter.hasNext())
                { listIter.next(); }
                
                while(listIter.hasPrevious())
                { listIter.previous(); }
                
                
    Collections  (Class)
    
            binarySearch(Collection e, key) - если выдает отрицательный элемент, значит элемент не найден
            
            
    Big O notation (Сложность алгоритмов) "Количество операций(шагов)"
            
            O(1) - самый быстрый(эффективный) и постоянный. Вне зависимости от количества элементов, метод get() проделает одинаковое количество операций. За константное время мы получаем любой элемент из массива.
            
            O(n) - линейный алгоритм или линейно расширяется. 
            
            O(logN) - по скорости хуже O(1), но лучше O(n). Используется в бинарном поиске 
            
            ArrayList - вставка в конец O(1), если есть путсые метса (capacity)
            если вышли за рамки capacity(size), то вставка будет равна O(n)
            Если удаляем из середины O(n)
            
            LinkedList - вставка в середину O(n), удаление в середине - O(n)
            добавление в начало занимает O(1)
    
    
    Vector
            Vector - устаревший synchronized класc. В своей основе содержит массив элементов Object.
            
            
    Stack 
            Stack - устаревший synchronized класc. Использует принцип LIFO.
                pop() - достает с вершины стека и удаляет
                peek() - достает с вершины стека без удаления
                push() - добавление элемента на вершину стека

    Map
        HashMap
            Элементами HashMap являются пары ключ/значение. HashMap не запоминает порядок добавления элементов. Его методы работают очень быстро.
            Ключи элементов должны быть уникальными. Ключ может быть null.
            Значения элементов могут повторяться. Значения могут быть null.
            "Не хранит порядок добавления"
            Если добавить повторно элемент с ключом, который был уже добавлен, то поменяется значение.
            
            В основе HashMap лежит массив. Элементами данного массива являются струтуры LinkedList.
            Данные структуры LinkedList и заполняются элементами, которые добавляем в HashMap.
            
            При создании HashMap мы можем задать 2 параметра, которые очень влияют на производительность: 
                - Initial capacity - начальный размер массива;
                - Load factor - коэффициент того, насколько массив должен быть заполнен,
                 после чего его размер будет увеличен вдвое
                
            O(1) - "Добавление и получение"
            
            put() - добавление элемента
            
            putIfAbsent() - добавь элемент в коллекцию, если такого элемента нет
            
            get() - возращает значение по ключу. Если такого ключа нет вернет null.
            
            containsValue() - возращает boolean, если есть или нет переданное значение.
            
            containsKey() - возращает boolean, если есть или нет переданного ключа. 
            
            keySet() - возращает множество ключей.
            
            values() - возращает множество значений.
            
            entrySet() - возращает множество.
            
            for (Map.Entry<DataType, DataType> entry : map.entrySet()){
                System.out.println(entry.getKey() + " : " + entry.getValue());
            }

    "Методы equals и hashcode"
            Если переопределяется equals(), то переопеределите и hashcode().
            Результат нескольких выполнений метода hashcode() для одного и того же обьекта должен быть одинаковым.
            Если, согласно методу equals(), два обьекта равны, то и hashcode() данных обьектов обязательно
            должны быть одинаковыми.
            "Если, согласно методу equals(), два обьекта НЕ равны, то hashcode() данных обьектов НЕ
            обязательно должны быть разными"
            Ситуации, когда результаты метода hashcode() для разных обьектов одинаков, называется "коллизией".
            Чем ее меньше, тем лучше.
            
            
    TreeMap
            Элементами TreeMap являются ключ/значение. В TreeMap элементы хранятся "в отсортированном по возрастанию порядке".
            
            В основе TreeMap лежит "красно-черное дерево". Это позволяет методам работать быстро, но не быстрее,
            чем методы HashMap.
            
            descendingMap() - сортировка от большего к меньше(по умолчанию от меньшего к большему)
            
            tailMap() - выведет все элементы, которые "больше" введенного ключа
            
            headMap() - выведет все элементы, которые "меньше" введенного ключа
            
            lastEntry() - выведет наибольше значение ключа
            
            firstEntry() - выведет наименьшее значение ключа


    LinkedHashMap
            LinkedHashMap является наследником HashMap. Хранит информацию о порядке добавления элементов или порядке их использования. Производительность методов немного ниже, чем у методов HashMap.
            
            LinkedHashMap<Double, Student> lhm =
                new LinkedHashMap<>(16, 0.75f, true); // initialCapacity(int), loadFactor(float), accessOrder(boolean)
            initialCapacity - первоначальный размер capacity
            loadFactor - параметр задает, при какой заполности нужно сделать перезапись
            accessOrder - false-стандарт | true-запонимает использование методов "влияет на сортировку"
            
        
    Hashtable
            Hashtable устаревший класс, который работает по тем же принципам, что и HashMap.
            В отличии от HashMap является synchronized. По этой причине его методы далеко не такие быстрые.
            
            В Hashtable ни ключи, ни значения не могут быть null.
            
            Даже если нужна поддержка многопоточности Hashtable лучше не использовать. Следует использовать ConcurrentHashMap.
            
            
    Set
            Set - коллекция, хранящая уникальные элементы. Методы данной коллекции очень быстры.
            
            HashSet не запоминает порядок добавления элементов. В основе HashSet лежит HashMap.

            У элементов данного HashMap: ключи - это элементы HashSet, значения - это константа-заглушка.
            
            
            
    HashSet
            addAll() - "union" - может работать для обьединения двух множеств
            
            retainAll() - "intersect" -может обьединить общие элементы
            
            removeAll() - "subtract" -может вывести разницу между множествами
            
            
    TreeSet
            TreeSet хранит элементы в отсортированном по возрастанию порядке.
            В основе TreeSet лежит TreeMap. У элементов данного TreeMap: ключи - это элементы TreeSet, значения - это константа-заглушка.
            
            first() - выведет первый элемент в множестве.
            
            last() - выведет последний элемент в множестве.
            
            headSet() - выведет элементы меньше заданного.
            
            tailSet() - выведет элементы больше или равно заданного.
            
            subSet() - выведет множество между двумя заданными значениями.
            
            
    LinkedHashSet
            LinkedHashSet является наследником HashSet. Хранит информацию о порядке добавления элементов.
            Производительность методов немного ниже, чем у методов HashSet.
            В основе LinkedhashSet лежит HashMap. у элементов данного HashMap: ключи - это элементы LinkedHashSet, значения - это константа-заглушка.
            
            
    Queue
            Queue - это коллекция, хранящая последовательность элементов. Длбавляется элемент в конец очереди, используется из начала очереди - правило FIFO.
            
            Класс LinkedList имплементирует не только интерфейс List, но и интерфейс Deque.
            
            add() - если очередь ограничена, то при добавлении заполненной очереди выбросит исключение.
            
            offer() - делает тоже самое, что и add(), но той же ситуации заполненной очереди, мы просто не сможем добавить элемент.
            
            remove() - при удалении элемента из уже пустой очереди выбросит исключение.
            
            poll() - при удалении элемента из уже пустой очереди выведет null.
            
            element() - выведет верхний элемент очереди. При попытке вывести элемент из уже пустой очереди выбросит исключение.
            
            peek() - выводит верхний элемент очереди без исключения. При пустой очереди выведет null.
            
            
    PriorityQueue
            PriorityQueue - это специальный вид очереди, в котором используется натуральная сортировка или та,
            которую мы описываем с помощью Comparable или Comparator. Таким образом используется тот элемент из очереди,
            приоритет которого выше.
            
            
    Deque
            Deque - double ended queue (двунаправленная очередь). В такой очереди элементы могут использоваться с обоих концов. Здесь работают оба правила - FIFO и LIFO.
            
            Интерфейс Deque реализуется классами LinkedList и ArrayDeque.
            
            addFirst() - добавление в начало очереди.
            
            addLast() - добавление в конец очереди.
            
            offerFirst() - добавление в начало без исключений
            
            offerLast() - добавление в конец без исключений
            
            
            removeFirst() - удаление в начале
            
            removeLast() - удаление в конце
            
            pollFirst() - удаление в начале без исключения
            
            pollLast() - удаление в конце без исключения
            
            getFirst() - вывести первый элемент 
            
            getLast() - вывести последний элемент 
            
            peekFirst() - вывести первый элемент без исключения 
            
            peekLast() - вывести последний элемент без исключения 
            
            
Nested class
    
    Nested "static" class
    
            Статический внутренний работает точно так же, как и обычный класс.
            
            - static nested класс очень похож на обычный внешний, но находится внутри другого класса.
            - Создавая обьект static nested класса, нужно указывать и класс, содержащий его.
    ("!!!") - static nested класс может содержать static и non-static элементы.
           
    ("!!!") - static nested класс может образаться даже к private элементам внешнего класса, но только к static.
    ("!!!") - Внешний класс может обращаться даже к private элементам static nested класса.
           
    
            public class Outer {
                static class Inner {
                }
            }
            
            class TestDrive {
                public static void main(String[] args) {
                    Outer.Inner inner = new Outer.Inner();
                }
            }
            
            
            
    Inner class
            
            При создании внутреннего класса "всегда" задействован обьект внешнего класса.
            - Каждый обьект inner класса всегда ассоциируется с обьектом внешнего класса.
            - Создавая обьект inner класса, нужно перед этим создать обьект его внешнего класса.
    ("!!!") - Inner класс может содержать только non-static элементы.
    ("!!!") - Inner класс может обращаться даже к private элементам внешнего класса
    ("!!!") - Внешний класс может обращаться даже к private элементам inner класса, прежде создав его обьект.
            - Inner класс может содержать final static члены.
            
            
            public class Outer {
                class Inner {
                }
            }
            
            class TestDrive {
                public static void main(String[] args) {
                    Outer outer = new Outer();
                    Outer.Inner inner = outer.new Inner();
                    
                    Outer.Inner inner2 = new Outer().new Inner();
                }
            }
            
            
    Local inner class
    
            - Local inner класс располагается в блоке кода таких, как, например, метод или конструктор.
            - Local inner класс не может быть static.
            - Область видимости local inner класса - это блок, котором он находится.
            - Local inner класс может обращаться даже к private элементам внешнего класса.
    ("!!!") - Local inner класс обращаться к элементам блока, в котором он может написать при условии,
              что он final или effectively final (не менялось значение).
    

    Anonymous inner class
    
            - Anonymous класс не имеет имени.
            - Anonymous класс - это "обьявление" класс и одновременное создание обьект.
            - В анонимных классах невозможно написать конструктор.
            - Анонимный класс может обращаться даже к private элементам внешнего класса
            Local inner класс обращаться к элементам блока, в котором он может написать при условии,
                          что он final или effectively final (не менялось значение).
            - Lambda expressions - краткая форма для написания анонимных классов.
            
             class Another {}
             
             class Main {
                Another getA() {
                    return new Another() {
                        // тело анонимного класса
                    }; // оченнь важно - это окончание выражения
                }
             }
            
            
Lambda expressions

            Чтобы использовать лямбда выражение интерфейс должен иметь один абстрактный метод.(функциональный интерфейс)
            
            Самый короткий вариант написания лямбда выражения:
                str -> str.name
            Более полный вариант написания лямбда выражения:
                (String str) -> {return str.name;}
                
            В лямбда выражении оператор стрелка разделяет параметр метода и тело метода.
            В лямбда выражении справа от оператора стрелка находится тело матода, которое было бы у метода соответствующего класс,
            имплементировавшего интерфейс с единственным методом.
            Вы можете использовать смешанный вариант написания лямбда выражения: слева от оператора стрелка писать короткий вариант,
            справа - полный. Или наоборот.

            Если вы используете полный вариант написания для части лямбда выражения справа от стрелки,
            то вы должны использовать слово return и знак ";"

            Левая часть лямбда выражения может быть написана в краткой форме, если метод интерфейса принимает 1 параметр,
            но если в лямбда выражении вы хотите писать данный параметр используя его тип данных,
            тогда уже вы должны писать левую часть выражения в скобках.

            Если в правой части лямбда выражения вы пишите более одного statement-a,
            то вы должны использовать его полный вариант написания.
            
            Лямбда выражения работают с интерфейсом, в котором есть только 1 абстрактный метод.
            Такие интерфейсы называются функциональными интерфейсами, т.е. интерфейсами,
            пригодными для функционального программирования.
            
            def( () -> 5 ); // если не примает параметр
            def( (x) -> x.length() );
            def( (String x) -> x.length() );
            def( (x,y) -> x.length() );
            def( (String x, String y) -> x.length() );
            
            interaface Intro {
                boolean check(DataType a);
            }
            
            static void foo(DataType a) {
                check(a)
            }
            public static void main(String[] args) {
                foo((DataType a) -> {return true;})
                foo(a -> true)
            }
            
    java.util.function;
    
        Predicate<T> - используется методом removeIf()
        
                            arrayList.removeIf(t -> t.length() < 5);
        
            interaface Predicate<T t> {
                boolean test(T t);
            }
            
            and() - метод двух проверок("И")
                Predicate<Student> p1 = p -> p.avgGrade > 7.5;
                Predicate<Student> p2 = p -> p.sex == 'm';

                info.testStudents(students, p1.and(p2)); // два условия
            
            or() - метод двух проверок("ИЛИ")
                Predicate<Student> p1 = p -> p.avgGrade > 7.5;
                Predicate<Student> p2 = p -> p.sex == 'm';

                info.testStudents(students, p1.or(p2)); // два условия
                
            negate() - метод "ОТРИЦАНИЯ"
                Predicate<Student> p6 = p -> p.sex == 'm';
                info.testStudents(students, p6.negate()); // будет 'f'
                
            
        Supplier<T> "Поставщик"
                T get();
            
            
        Consumer<T> "Потребитель" - используется методом forEach()
                void accept(T t);
                
                
        Function<T,R>
                R apply(T t);
                
                
                
Stream
            Stream - это последовательность элементов поддерживающих последовательные и параллельные операции над ними.
            
            Методы Stream не меняют саму коллекцию или массив, от которой был создан stream
    
    Методы Stream
    
        " !!! stream нельзя переиспользовать !!! "
        
        map() - от Function<T, R> - element -> element+1 (Возращает значения)
        intermediate(lazy)
                
        filter() - принимает Predicate<T> - boolean intermediate(lazy)
                
        forEach() - возращает void (terminal meethod(eager))
        
                метод "reverens" 
                        int[] array = {5, 9, 3, 8, 1};
                        Arrays.stream(array).forEach(System.out::println);
                            "каждый элемент передается в println, который находится в System.out"
                
        rebuce() - уменьшение элементов (terminal meethod(eager))
                    int result = list.stream().reduce((accumulator, element)
                                -> accumulator * element).get();
                                System.out.println(result);
                                // 5, 8, 2 ,4 ,3
                                // accumulator =    5   40  80  320  960
                                // element =        8   2   4   3
                                // accumulator присваивает после операции
                                // element берет следующие значение
                    Optional<Integer> optional = list.stream().reduce((accumulator, element)
                                -> accumulator * element);
                    if(optional.isPresent()) {
                        System.out.println(optional.get());
                    } else {
                        System.out.println("Not present");
                    }
                    
                    int result2 = list.stream().reduce(1, (accumulator, element)
                                -> accumulator * element);
                            System.out.println(result);
                    // 5, 8, 2 ,4 ,3
                    // accumulator =    1   5   40  80  320  960
                    // element =        5   8   2   4   3
                
        sorted() - сортировка (intermediate(lazy))
                    students = students.stream().sorted((x,y) -> {
                                return x.getName().compareTo(y.getName());
                                }).collect(Collectors.toList());
        
        
        Работа метод chaining в stream
                source -> intermediate(lazy) -> terminal meethod(eager)
                
                
        concat() - конкатенация 
                    Stream<Integer> stream2 = Stream.of(1,2,3,4,5);
                    Stream<Integer> stream3 = Stream.of(6,7,8,9,10);
                    Stream<Integer> stream4 = Stream.concat(stream2,stream3);
                    stream4.forEach(System.out::println);
                
        distinct() - intermediate method - уникальные значения
                    Stream<Integer> stream5 = Stream.of(1,2,3,4,5,1,2,3);
                    stream5.distinct().forEach(System.out::println);
               
        count() - terminal method - количество элементов в stream, возращает long.
            
            
        peek() - intermediate method - смотреть по этапно, как работает метод chaining.
        
        flatMap() - intermediate method - работает с элементами элементов
        
                    facultyList.stream().flatMap( faculty
                            -> faculty.getStudentsOnFaculty().stream())
                            .forEach(e -> System.out.println(e.getName()));
        
        
        collect() - terminal method -
        
                groupingBy() - группировка по критерию. 
                
                partitioningBy() - разделение по (Predicate)true или false
        
        
        findFirst() - terminal method - выводит первый элемент - выдает Optional - значит надо использовать метод get()
        
        min() - terminal method -
        
        max() - terminal method -
        
        limit() - intermediate method - отбирает n элементов
                            students.stream().filter(e-> e.getAge()>20).limit(2).forEach(System.out::println);

        skip() - intermediate method - пропускает n элементов
        
        
        mapToInt() - intermediate method -
        
        boxed() - intermediate method - конфертирует значения Stream.
        
        
    Parallel stream
            
            Parallel stream - это возможность использования нескольких ядер процессора при выполнении каких-либо операций со stream
            
            Создание:
                list.parallelStream()."..." // из готового листа
                
                Stream<T> s = Stream.of(...);
                s.parallel."..."
                
                
Multithreading

            Многопоточность - это принцип построения программы, при котором несколько блоков кода могут выполняться одновременно.
            
            // Создание 
            class MyThread extends Thread{ public void run(){ код } }
            // Запуск 
            new MyThread().start();
                
            
            // Создание 
            class MyRunnablelmp implements Runnable{ public void run(){ код } }
            // Запуск
            new Thread(new Runnable() ).start();
            
            Из за того, что в Java отсутствует множественное наследование, чаще используют 2-ой вариант.
                
                
    Методы Thread
    
            setName() - устанавливает имя потока
            
            getName() - получаем имя потока
            
            setPriority() - устанавливается приотритет потока (От 1 до 10( наивысший приоритет), но нет гарантии, что он точно выполниться)
            
            getPriority() - получаем приоритет потока
                
            currentThread() - текущий поток, можно использовать, как "this"
                
            sleep() - усыпить поток на указанное время (выбрасывает исключение InterruptedException)
            
            join() - ожидание окончания выполнения вызванного потока (выбрасывает исключение InterruptedException), метод принимает как параметр "ms", при вводе параметра задется условия ждать пока выполниться поток или ждать истечения заданного времени
                
            getState() - состояние потока (NEW(После создание), RUNNABLE(после запуска), TERMINATED(после завершение))
                
    Concurrency / Parallelism
                Concurrency - согласованность
                Concurrent - параллельный
                
                    "Concurrency" означает выполнение сразу нескольких задачю В зависимоти от процессора компьютера concurrency может достигаться разными способами.
                    
                    "Parallelism" означает выполенение 2-х и более задач в одно и то же время, т.е. параллельно. В компьютерах с многоядерным процессором concurrency может достигаться за счет parallelism.
                    
    Asynchronous / Synchronous
                
                В "синхронном" программировании задачи выполняются последовательно друг за другом.
                в "асинхронном" программировании каждая следующая задача НЕ ждет окончания выполнения предыдущей. Асинхронное программирование помогает достичь concurrency.
                
                
    Ключевое слово volatile (изменчивый\непостоянный)
    
            Ключевое слово volatile используется для пометки переменной, как хранщей только в основной памяти "main memory".
            
            Для синхронизации значения переменной между потоками ключевое слово volatile используется тогда, когда только один поток может изменять значение этой переменной, а остальные его только читать.
                
                
    Data race и synchronized методы
        
            Data race - это проблема, которая может возникнуть когда два и более потоков обращаются к одной и той же переменной и как минимум 1 поток ее изменяет.
            
            synchronized - позволяет поставить lock на метод вовремя выполнения потока, который в него вошел, другие потоки будут ждать завершения выполнения.
                    public synchronized void abc() { method body }
            
    
    Понятие "монитор" и synchronized блоки
    
            "монитор" есть у каждого класса и обьекта
                у него два статуса ("свободен/занят")
            
            Монитор - это сущность/механизм, благодаря которому достигается корректная работа при синхронизации. В Java у каждого "класса" и "обькта" есть привязанный к нему монитор.
            
                    public void abc(){
                        synchronized (this) {
                            Method body;
                        }
                    }
                    
                    synchronized(SynchronizedBlock.class) {
                        Method body;
                    }
                Пример блока:
            
                    static final Object lock = new Object();
                    public void abc() { 
                        method body;
                        synchronized(lock) {
                            block body; 
                        } method body;
                    }
                
                
    Методы wait и notify
            
            Для извещения потоком других потоков о своих действиях часто используется следующие методы:
            
            wait() - (Выбрасывает "исключение" InterruptedException) - Можно ввести параметр времени "ms", макс. время ожидания потока - освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify();
            
            notify() - НЕ освобождает монитор и будит поток, к которого ранее был вызван метод wait();
            
            notifyAll() - НЕ особождать монитор и будит все потоки, у которых ранее был вызван метод wait();
            
            
    Понятия Deadlock, Livelock, Lock Starvation       
            
            Deadlock - ситуация, когда 2 или более потоков залочены навсегда, ожидают друг друга и ничего не делают.
            
            Livelock - ситуация, когда 2 или более потоков залочены навсегда, ожидают друг друга, проделывают какую-то работу, но без какого-либо прогресса.
            
            Lock starvation - ситуация, когда менее приоритетные потоки ждут долгое время или все время для того, чтобы могли запуститься.
            
    
    Lock и ReentrantLock
    
            Lock - интерфейс, который имплементируется классом ReentrantLock/
            
            Так как ключевое слово synchronized, Lock нужен для достижения синхронизации между потоками.
            
            lock() - активация 
            
            unlock() - деактивация
            
            tryLock() - делает lock, когда ресурс свободен(в обратном случаи ждет)
            
            
    Daemon потоки
            
            Daemon потоки предназначены для выполнения фоновых задач и оказания различных сервисов User потокам.
            
            При завершении работы последнего User потока программа завершает свое выполнение, не дожидаясь окончания рабоыт Daemon потоков.
            
            Обьявить Daemon поток легко нужно перед запуском("обязательно") вызвать метод setDaemon()
            
            setDaemon() - уставливает поток, как Daemon поток.
            
            isDaemon() - проверка на Daemon.
            
    
    Прерывание потоков    
            
            У нас есть возможность послать сигнал потоку, что мы хотим его прервать.
            У нас также есть возможность в самом потоке проверить, хотят ли его прервать. Что делать, если данная проверка показала, что поток хотят прервать, должен решать сам программист.
            
            interrupt() - вызывом из другого потока мы посылаем сигнал другому потоку, что его хотят прервать.
            
            isInterrupted() - проверка на то, хотят ли прервать поток
    
    Thread pool и ExecutorService
    
            Thread pool - это множество потоков, каждый из которых предназначен для выполнения той или иной задачи.
            
            В Java с thread pool-ами удобнее всего работать посредством ExecutorService.
            
            Thread pool удобнее всего создавать, используя factory методы класса Executors:
                    Executors.newFixedThreadPool(int count) - создаст pool с 5-ю потоками;
                    Executors.newSingleThreadExecutor() - создаст pool с одним потоком
            
            Метод execute() передает наше задание (task) в thread pool, где оно выполняется одним из потоков.
            После выполнения метода shutdown() ExecutorService понимает, что новых заданий больше не будет и, выполнив поступившие до этого задания, прекращает работу
            Метод awaitTermination() принуждает поток в котором он вызвался подождать до тех пор, пока не выполнится одно из двух событий: либо ExecutorService прекращает свою работу, либо пройдет время, указанное в параметре метода awaitTermination().
            
                    ExecutorService executorService = Executors.newFixedThreadPool(5);
                    for(int i =0; i <10; i++) {
                        executorService.execute(new RunnableImpl100()); // даем задание
                    } 
                    executorService.shutdown(); // если не поставить завершение, будет постоянно ожидать новые task.
            
            execute() - передает задание pool-у
            
            shutdown() - прекращение работы ExecutorService
            
            awaitTermination(5, TimeUnit.SECONDS) - (Выбрасывает исключение InterruptedException) - второй параметр задает в чем мерить время ожидания - заставляет ожидать поток, в котором он вызывается (как join()).
            
            
    ScheduledExecutorService        
            
            ScheduledExecutorService используется тогда, когла хотим установить расписание на запуск потоков из пула.
            Данный pool создается, используется factory метод класса Executors:
            
                    Executors.newScheduledThreadPoll(int count) // кол-во потоков
            
            schedule() - расписание выполнения потока
            
                        schedule(new RunnableImpl(), 3, TimeUnit.SECONDS); // через сколько должно выполниться (3 секунды)
            
            scheduleAtFixedRate() - доп. параметр с какой переодичностью(это время начала запуска первого таска и начало второго таска("НЕ время между завершением первого таска и началом второго"))
            ** Если время выполнения таска превышает заданный интервал, то между заданиями не будет задержки
            
                        scheduledExecutorService.scheduleAtFixedRate(new RunnableImpl200(), 3 ,1, TimeUnit.SECONDS); // первый вызов потока через 3 секунды, каждый последующий через 1 секунду, если время выполнения превышает одну секунду, то выолнение будет сразу после завершения таска.
                        
            scheduleWithFixedDelay() -
            
                        scheduledExecutorService.scheduleAtFixedRate(new RunnableImpl200(), 3 ,1, TimeUnit.SECONDS); // первый вызов потока через 3 секунды, второй параметр время между оканчанием первого задания и началом второго 1 секунда.
            
            
            ExecutorService executorService = Executors.newCachedThreadPool(); 
            // создает thread pool по надобности, использует свободные потоки. Если заданий нет запускается счеткик, который отсчитывает 60 секунд и удаляет не задейственный поток
            
            
    Интерфейсы Callable и Future
            
            Callable, также как и Runnable, представляет собой определенное задание, которое выполняется потоком.
            В отличии от Runnable Callable:
                - имеет return type не void;
                - может выбрасывать Exception;
                
            Метод submit() передает наше задание(task) в thread pool, для выполнения его одним из потоков, и возращает тип Future, в котором и хранится результат выполнения нашего задания.
            Метод get() позволяет получить результат выполнения нашего задания из обьекта Future.
            
                        public interface Callable <V> {
                            V call() throws java.lang.Exception;
                        }
            
            execute() - "!!!" c Callable не работает, он принимает только Runnable
            
            Вместо него есть метод submit()
            
            submit() - выдает задание thread pool
            
            так как имеет возращающий тип. Для присвоения этого значения нужно использовать тип Future<T>
            
            Чтобы получить значение из переменной типа Future<t> future нужно использовать его методом get() - (Выбрасывает "исключение" InterruptedException, ExecutionException)
        
            
    Semaphore
        
            Semaphore - это синхронизатор, позволяющий ограничить доступ к какому-то ресурсу. В конструктор Semaphore нужно передавать количество потоков, которым Semaphore будет разрешать одновременно использовать этот ресурс
            
            acquire() - уменьшает счечик Semaphore
            
            release() - освобождает место 
            
            
    CountDownLatch
    
            CountDownLatch - это синхронизатор, позволяющий любому количеству потоков ждать пока не завершиться определенное количество операций. В конструктор CountDownLatch нужно передавать количество операций, которые должны завершится, чтобы потоки продолжалили свою работу.
            
            await() - Выбрасывает "исключение" InterruptedException) - если счетчик больше 0, наш проток будет заблокирован, до тех пока счеткик не станет равен 0.
            
            countDown() - уменьшаем счетчик
            
            getCount() - текущие значение счетчика
            
            
    Exchanger
        
            Exchanger - это синхронизатор, позволяющий обмениваться данными между двумя потоками, обеспечивает то, что оба потока получат информацию друг от друга одновременно.
            
            exchange() - используется для обмена.
            
            
    AtomicInteger
    
            AtomicInteger - это  класс. который предоставляет возможность работть с целочисленным значением int, используя атомарные операции.
            
            incrementAndGet() - инкрементировать, потом получить значение
            
            getAndIncrement() - получить значение, потом инкрементировать
            
            addAndGet() - прибавляет значение, которое передано в параметре
            
            getAndAdd() - возращает старое значение, потом прибавляет переданный параметр
            
            decrementAndGet() - уменьшить на единицу и верни
            
            getAndDecrement() - верни старое значение, потом уменьшить на единицу
            
    
    "Синхронизированные коллекции"
            
        Коллекции для работы с многопоточностью    
            
            Synchronized collections 
                    - Получаются из традиционных коллекций благодаря их обертыванию
            
            Concurrent collections
                    - Изначально созданы для работы с многопоточностью
            
        Collections.synchronized"XYZ"(коллекция)
        
        
    ConcurrentHashMap
        
            ConcurrentHashMap имплеменирует интерфейс ConcurrentMap, который в свою очередь происходит от интерфейса Map.
            В ConcurrentHashMap любое количество потоков может читать элементы не блокируя его.
            В ConcurrentHashMap, благодаря его сегментированию, при изменении какого-либо элемента блокируется только bucket, в котором он находится.
            
            В ConcurrentHashMap ни "key", ни "value" не могут быть null.
            
            
    CopyOnWriteArrayList    
            
            CopyOnWriteArrayList имплементирует интерфейс List.
            
            CopyOnWriteArrayList следует использовать тогда, когда вам нужно добиться потокобезопастности, у вас небольшое количество операций по изменению элементов и большое количество по их чтению.
            
            
    ArrayBlockingQueue        
            
            ArrayBlockingQueue - потокобезопасная очередь с ограниченным размером (capacity restricted)
            
            Обычно один или несколько потоков добавляют элементы в конец очереди, а другой или другие потоки забирают элементы из начала очереди.
            
            put() - добавляет элемент
            
            take() - забирает элемент их очереди
            
            
"Работа с файлами": IO и NIO            
            
    Character Streams and Byte Streams
    
            Stream (поток) для работы с файлами - это упорядоченная последовательность данных.
            
            Файлы разделяют на
                - читабельные для человека - text files;
                - нечитабельные для человека - binary files;
                
            При работе с текстовыми и бинарными файлами нам необходимо использовать разные типы стримов.
            
    FileReader & FileWriter
    
            FileReader и FileWriter используются для работы с текстовым файлами.
            
        FileWriter
            
                FileWriter writer = writer = new FileWriter("путь до файла", true); //true append, можно не задавать, но при запуске будет перезапись файла.
                
                write() - (Выбрасывает "исключение" IOException) - запись

        ("!!!") close() - (Выбрасывает "исключение" IOException) - необходимо закрывать FileWriter
            
            
        FileReader   
        
                FileReader writer = writer = new FileReader("путь до файла");
                
                    int character;
                    while ((character= reader.read()) != -1) {
                        System.out.println((char) character);
                    }
            
                read() - (Выбрасывает "исключение" IOException) - возращает int, когда символов нет возращает -1.
            
        ("!!!") close() - (Выбрасывает "исключение" IOException) - необходимо закрывать FileReader
            
            
        !!!"Никогда не забывайте закрывать стримы после использования"!!!  
            
            
    Try with resourses        
            
        try ( FileWriter writer = writer = new FileWriter("путь до файла", true);
        FileReader writer = writer = new FileReader("путь до файла"); ) {
            //SOME CODE...
        }
            
        Ресурс, который используется в Try with resourses должен имплементировать интерфейс AutoCloseable
            
            
            
    BufferedReader & BufferedWriter        
            
            Использование буферизации в стримах позволяет достичь большей эффективности при чтении файла или записи в него.    
                
                BufferedWriter write = new BufferedWriter(new FileWriter("file.txt"));
                
                BufferedReader write = new BufferedReader(new FileReader("file.txt"));
                        
                        "Способы записи":
                            int character;
                            while((character= reader.read())!= -1) {
                                writer.write(character);
                            }

                            String line;
                            while ((line= reader.readLine())!= null) {
                                writer.write(line);
                                writer.write('\n');
                            }
            
            
    FileInputStream & FileOutputStream
    
            FileInputStream и FileOutputStream используются для работы с бинарными файлами.
            
                FileInputStream inputStream = new FileInputStream("file.bin");
                    
                FileOutputStream outputStream = new FileOutputStream("file.bin");
                    
    
    DataInputStream & DataOutputStream
    
            DataInputStream и DataOutputStream позволяет записывать в файл и читать из него примитивные типы данных.
            
                DataInputStream inputStream = new DataInputStream(new FileInputStream("file.bin"));
            
                DataOutputStream outputStream = new DataOutputStream(new FileOutputStream("file.bin"));
            
            
    Serializaton (Сериализация)
            
            Сериализация - это процесс преобразования обьекта в последовательность байт.
            Десериализация - это процесс восставновления обьекта, из этих байт.
            
            Для того, чтобы обьект класса можно было сериализовать, класс должен имплементировать интерфейс Serializable.
            Поля класса, помеченные ключевым словом transient, не записываются в файл при сериализации.
            
            В сериализируемом классе необходимо использовать serialVersionUID для обозначения версии класса.
            
                ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream("file.bin"));
                
                ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream("file.bin"));
            
                writeObject() -
                
                readObject() - 
            
            Ключевое слово transient, используется для чтобы при сериализации переменная не была сериализована.
            
    
    RandomAccessFile
    
            Класс RandomAccessFile позволяет читать информацию из любого места файла и записывать информацию в любое место файла.
    
            RandomAccessFile file = new RandomAccessFile("file.txt", "rw") // второй параметр конструктора задает mode режим в данном случае read(чтение) и write(запись).
            
            read() - int - задает расположение pointer(курсора), читает по одному байту
            
            readLine() - String - читает строку
            
            seek() - перемещение pointer(курсора) между байтами в нужный указанный
            
            getFilePointer() - long - возращает позицию pointer(курсора)
            
            writeBytes() - String - запись строчки
    
    
    File
    
            Класс File позволяет управлять информацией о файлах и директориях.
    
                File file = new File("file.txt");
    
            getAbsolutePath() - возращает абсолютный путь файла
    
            isAbsolute() - проверка на абсолютный путь (возращает true/false)
    
            isDirectory() - проверка на директорию (возращает true/false)
    
            exists() - проверка на сущетсвование файла (возращает true/false)
            
            createNewFile() - создание файла (возращает true/false)
            
            mkdir() - создание директории (возращает true/false)
            
            length() - размер файла
    
            delete() - удаление файла/директории. Если директория не пустая, то удаление не произойдет (возращает true/false)
    
            listFiles() - File - возращает список файлов 
                    File[] files = folder.listFiles();
                    System.out.println(Arrays.toString(files));
            
            isHidden() - проверка на скрытый файл (возращает true/false)
            
            canRead() - проверка на доступ чтения файла (возращает true/false)
            
            canWrite() - проверка на доступ записи файла (возращает true/false)
            
            canExecute() - проверка на доступ выполнения файла (возращает true/false)
    
    
    Buffer and Channel
    
            Buffer - Это блок памяти, в который мы можем записывать информацию, а также читать ее.
            В отличии от стримов Channel может как читать файл, так и записывать в него.
            
            Чтение файла: Channel читает информацию из файла и записывать в Buffer.
            Запись в файл: Channel читает информацию из Buffer и записывать ее в файл
            
                RandomAccessFile file = new RandomAccessFile("file.txt", "rw");
                FileChannel channel = file.getChannel();
            
            ByteBuffer buffer = ByteBuffer.allocate(25); // устанавливает размер буфера 25 байт
            
            flip() - меняет режим Buffer(при смени режима, pointer(курсора) меняет свои расположение на 0 позицию
            
            clear() - меняет расположение pointer(курсора). Не происходит очистка буффера.
            
            hasRemaining() - проверка есть ли, что еще байты для чтения
            
            get() - получение байта(не забывать про кастинг)
                String text = "text";
                ByteBuffer buffer3 = ByteBuffer.wrap(text.getBytes()); 
                    wrap() - делает запись в буфер - принимает массив байт. Сам делает flip() для чтения и перемещает pointer(курсора) на 0 позицию. Сам устанавливает нужный для введеного массива буфер
 
            rewind() - ставит pointer(курсора) на 0 позицию в буфере
            
            compact() - копирует непрочитанные байты(схожая работа с методом clear(), но clear() делает перезапись)
            
            mark() - делает метку на текущем байте.
            
            reset() - возращает pointer(курсора) на позицию метки.
            
    
    Interface Path & class Files
    
            Обьект типа Path представляет собой путь к файлу или директории.
            
                    Path path = Paths.get("file.txt");
            
            getFileName() - возращает имя файла/диретории из Path.
            
            getParent() - возращает имя родителя файла/диретории из Path.
            
            getRoot() - возращает корень файла/диретории из Path.
            
            isAbsolute() - проверка на абсолютный путь (возращает true/false)
            
            toAbsolutePath() - возращает абсолютный путь файла/диретории из Path.
            
            resolve(Path path) - обьединение пути в один
            
            relativize(Path path) - возвращает относительный путь, относительно вызываемого пути.
            
            
        Files
            
            Files.exists(Path path) - проверка на существование файла/директории по переданному пути (возращает true/false)
            
            Files.createFile(Path path) - создает файл по переданному пути.
            
            Files.createDirectory(Path path) - создает директорию по переданному пути.
            
            Files.isReadable(Path path) - проверка прав на чтение файла (возращает true/false)
            
            Files.isWritable(filePath) - проверка прав на запись файла (возращает true/false)
            
            Files.isExecutable(filePath) - проверка прав на выполнение файла (возращает true/false)
            
            Files.isSameFile(Path path1, Path path2) - проверка на соотвествие путей. Является path1 и path2 одним и тем же путем(Может быть  такое, что path1 это относительный путь, а path2 абсолютным)
            
            Files.size(Path path) - размер файла (в байтах)
            
            Files.getAttribute(Path path, "creationTime") - возращает атрибуты файла. Второй параметр записывается в String(creationTime, size и другие)
            
            Map<String, Object> attributes = Files.readAttributes(filePath, "*") - Возращает выбранные или все атрибуты
            
            Files.copy(path1, path2, copy_options) - копирование path1, в path2
                    
                    Files.copy(filePath,directoryPath.resolve("fileName.txt")) - копирование с изменением имени файла
                    
                    Files.copy(filePath,directoryPath.resolve(filePath), StandardCopyOption.REPLACE_EXISTING) - копирование с заменой файла(Если не прописать дополнительную опцию, а файл уже существует вылетит Exception)
                    
                    Files.copy(directoryPathZ, directoryPath.resolve("Z")) - копирование директории.(Если в копируемой директории есть содержиомое, то copy() не скопирует его)

            Files.move(path1, path2, copy_options) - перемещение файла. С помощью move() можно переименовать файл, нужно лишь пеместить файл в тот же адрес, но с другим именем
            
                            Files.move(filePath, directoryPath.resolve("file.txt"));

            Files.delete(path) - удаление
            
            Files.write(path, byte_array) - запись в файл
            
                    String dialog = "text";
                    Files.write(filePath, dialog.getBytes());
            
            Files.readAllLines(path) - чтение файла
            
                    List<String> list = Files.readAllLines(filePath);

            
        Files.walkFileTree
        
            Метод Files.walkFileTree(Path start, FileVisitor vositor) используется для обхода дерева файлов.
            Логика обхода дерева файлов заключается в классе, имплементирующем интерфейс FileVisitor.
            
            preVisitDirectory() - срабатывает перед обращением к элементам папки;
            
            visitFile() - срабатывает при обращении к файлу;
            
            postVisitDirectory() = срабатывает после обращения ко всем элементам папки;
            
            visitFileFailed() - срабатывает когда файл по каким-то причинам недоступен.
            
                    enum FileVisitResult
                    
                        Значения FileVisitResult:
                        
                        CONTINUE - означает, что нужно продолжать обход по файлам;
                        TERMINATE - означает, что нужно немедленно прекратить обход по файлам;
                        SKIP_SUBTREE - означает, что в данную директорию заходить не надо;
                        SKIP_SIBLINGS - означает, в данной директории продолжать обход по файлам не нужно.
        
        class SimpleFileVisitor<T> // если не хотим переопределять все методы FileVisitor
            preVisitDirectory() - срабатывает перед обращением к элементам папки;
            
            visitFile() - срабатывает при обращении к файлу;
            
            postVisitDirectory() = срабатывает после обращения ко всем элементам папки;
            
            visitFileFailed() - срабатывает когда файл по каким-то причинам недоступен.
            
            
REGular EXpressions

        Регулярные выражения необходимы для создания шаблонов, с помощью которых производят такие операции, как поиск, сравнение, замена.
            
        Регулярные выражения - это совокупность символов, некоторые из которых являются специальными - метасимволами,  т.е. обладают каким-то функционалом.
        
        Пакет: java.util.regex
        
        Pattern myPattern = Patter,compile("REGEX");
        Matcher myMatcher = myPattern.matcher(myString);
        
            
        String text = "text";
        Pattern pattern = Pattern.compile("шаблон");    // создаем шаблон
        Matcher matcher = pattern.matcher(text);         // поиск по шаблону
            
        while(matcher.find()) { // find() возращает true, если было найдено совпадение
            System.out.println("Position: " + matcher.start() + "   " + matcher.group()); // group() вывод найденных совпадений; star() начало позиции совпадения
        }   
        
        
        String myString = "12345678900987650325213;" +
                "92359072529387020927349;" +
                "32749327294831321231237";
        // 03/25 1234 5678 9009 8765 (213)

        Pattern pattern =
                Pattern.compile("(\\d{4})(\\d{4})(\\d{4})(\\d{4})(\\d{2})(\\d{2})(\\d{3})");
        Matcher matcher = pattern.matcher(myString);

        String myNewString = matcher.replaceAll("$5/$6 $1 $2 $3 $4 ($7)"); // запись по группам(Нумерация начинается с 1)
        
        while (matcher.find()) {
            System.out.println(matcher.group(7));
        } // возращает 7 группу
         
        Часто используемые символы в REGEX
            
            abc - Соответствует последовательно идущим abc
            
            [abc] - Соответствует или a, или b, или c
            
            [d-j] - Соответствует одной из букв из диапозона d-j
            
            [3-8] - Соответствует одной из цифр из диапозона 3-8
            
            [B-Fd-j3-8] - Соответствует одной из букв из обоих диапозонов или одной из цифр из диапазона 3-8
            
            a|b - Соответствует либой букве a, либо букве b
            
            [^d-j] - Данный символ, стоящий в начале этих скобок, означает отрицание. Соответствует одной из букв НЕ из диапазона d-j
            
            [.] - Соответствует одному любому символу. Исключение: символ новой строки
            
            ^выражение - Соответствует выражению в начале строки
            
            выражение$ - Соответствует выражению в конце строки
            
        Часто используемые МЕТАсимволы в REGEX
        
            \d - Соотвествует одной цифре
            
            \D - Соответствует одной НЕ цифре
            
            \w - Соответствует одной букве, цифре или "_"
            
            \W - Соответствует одному символу, который НЕ буква, Не цифра и НЕ "_"
            
            \s - Соответствует пробельному символу
            
            \S - Соответствует не пробельному символу
            
            \A - Соответствует выражению в начале String-a
            
            \Z - Соответствует выражению в конце String-a
            
            \b - Соответствует границе слова или числа
            
            \B - Соответствует границе НЕ слова и НЕ числа
            
        Часто используемые символы в REGEX, обозначающие количество повторений
        
            выражение? - Соответствует 0 или 1 повторению
            
            выражение* - Соответствует 0 или большему количеству повторений
            
            выражение+ - Соответствует 1 или большему количеству повторений
            
            выражение{n} - Соответствует количеству повторений "n"
            
            выражение{m, n} - Соответствует количеству повторений от "m" до "n"
            
            выражение{n, } - Соответствует n или большему количеству повторений
            
    
    Методы класса String: matches() и split()
    
            public boolean matches(String regex)
                    
                    String s2 = "chuck@gmail.com";
                    boolean result = s2.matches("\\w+@\\w+\\.(com|ru)"); // true

            
            public String[] split(String regex)
            
            
    Методы printf() и format()
    
            %[flags][width][.precision]datatype_specifier
            
        flags
                "-" - выравнивание по левому краю
                
                "0" - добавление нулей перед числом
                
                "," - разделитель разрядов в числах
                
        DT specifiers   
                "b" - boolean
                
                "c" - Character
                
                "s" - String
                
                "d" - целое число
                
                "f" - десятичное число
        
                System.out.printf("%03d \t %-12s \t %-12s \t %,.1f \n", emp.id, emp.name, emp.surname, emp.salary * (1 + emp.bonusPct));

                String newString = String.format("%03d \t %-12s \t %-12s \t %,.1f \n", 1, "Zaur", "Tregulov", 12345 * (1 + 0.15)); // сохранение формата вывода
                
                
Enum

        enum - это способ ограничения определенного рода информации конкретным списком возможных вариантов
        Конструктор в enum имеет access modifier private и не нуждается во внешнем вызове
        enum является дочерним классом для java.lang.Enum
        Часто используемые методы: valueOf(), values()
        
        valueOf() - возращает элемент enum из какого-то String значения
               
                WeekDays w15 = WeekDays.valueOf("MONDAY"); // важно писать без ошибок
        
        values() - возращает массив констант enum
              
                WeekDays[] array = WeekDays.values();
        
        Конструктор - всегда private(по умолчанию)
            
            
Scanner

                Scanner scanner = new Scanner(System.in); // работа с консолью
                int i = scanner.nextInt();
                
                nextLine() - читает строку
                
                hasNextLine() - проверка, есть ли следующая строка

            
Reflection

        Рефлексия - это механизм ислледования данных о программе во время выполнения.
        Рефлексия позволяет исследовать информацию о полях, методах, конструкторах и других составляющих классов.
            
            Варианты создания:
            
                Class clazz = Class.forName("package_name.Class_name");
                
                Class clazz = Class_name.class;
                
                Class_name c = new Class_name();
                Class clazz = c.getClass();
            
        Field someField = employeeClass.getField("id"); //
        someField.getType(); // возращает тип поля
        
        Field[] fields = employeeClass.getFields(); // возращает все поля(кроме pivate)
        getName() - возращает имя поля
        getType() - возращает тип поля
            
        Field[] fieldsAll = employeeClass.getDeclaredFields(); // возращает все поля даже private
        
        
        Method someMethod = employeeClass.getMethod("increaseSalary");
        System.out.println("return type of method increaseSalary = " + someMethod.getReturnType() + ", parametr types = " + Arrays.toString(someMethod.getParameterTypes()));
        
        Method someMethod2 = employeeClass.getMethod("setSalary", double.class); // если метод с параметром
        System.out.println("return type of method increaseSalary = " + someMethod2.getReturnType() + ", parameter types = " + Arrays.toString(someMethod2.getParameterTypes()));
            
        Method[] methods = employeeClass.getMethods(); // возращает все методы включая унаследованные, кроме private
        for (Method method : methods) {
            System.out.println("Name of method " + method.getName() +
                    ", return type = " + method.getReturnType() +
                    ", parameter types = " + Arrays.toString(method.getParameterTypes()));
        } 
        
        Method[] methodsAll = employeeClass.getDeclaredMethods(); // возращает все прописанные методы, кроме унаследованных
        for (Method method : methodsAll) {
            System.out.println("Name of method " + method.getName() + ", return type = " + method.getReturnType() + ", parameter types = " + Arrays.toString(method.getParameterTypes()));
        }    
            
        Method[] methodsAll2 = employeeClass.getDeclaredMethods();
        for (Method method : methodsAll) {
            if (Modifier.isPublic(method.getModifiers())) { // вывести все методы с модификатором public
                System.out.println("Name of method " + method.getName() + ", return type = " + method.getReturnType() + ", parameter types = " + Arrays.toString(method.getParameterTypes()));
            }
        }    
            
        Constructor constructor1 = employeeClass.getConstructor();
        System.out.println("Constructor has " + constructor1.getParameterCount() + " parameters, their types are: " + Arrays.toString(constructor1.getParameterTypes()));
        System.out.println("*****");

        Constructor constructor2 = employeeClass.getConstructor(int.class, String.class, String.class);
        System.out.println("Constructor has " + constructor2.getParameterCount() + " parameters, their types are: " + Arrays.toString(constructor2.getParameterTypes()));
            
        Constructor[] constructors = employeeClass.getConstructors();

        for(Constructor constructor: constructors) {
            System.out.println("Constructor " + constructor.getName() + ", has " + constructor.getParameterCount() + " parameters, their types are: " +  Arrays.toString(constructor.getParameterTypes()));
        }
        
        
    Создание обьекта с помощью рефлексии
    
        Class clazz = Class.forName("package_name.Class_name");
        Object o = (Class_name) clazz.newInstance(); // устаревший метод
        
        Class clazz = Class.forName("package_name.Class_name");
        Constructor<Class_name> constructor = clazz.getConstructor();
        Class_name obj = constructor.newInstance();    
        
        Class clazz = Class.forName("package_name.Class_name");
        Constructor constructor = clazz.getConstructor(int.class, String.class, String.class);
        Object obj = constructor.newInstance(13, "text", "text");    
            
    Использование метода с помощью рефлексии       
        
        Method method = clazz.getMethod("method_name", double.class);
        method.invoke(obj, 800.88);
        
        
    Получение доступа к private полю
    
        Class_name obj = new Class_name(10, "text", "text");
        Class clazz = obj.getClass();
        Field field = clazz.getDeclaredField("private_field");
        field.setAccessible(true); // говорим, что хотим получить доступ private полю
        double private_field_new = (Double) field.get(obj);
        
    Поменять значение поля
    
        field.set(obj, new_value);
        
        
Annotation

        Аннотации - это специальные коментарии/метки/метаданные, которые нужны для передачи определенной информации.
        
        @Target показывает область кода, к которой Аннотация может быть применима. Самые распространенные области кода:
            
            TYPE - class, interaface, enum;
            
            FIELD - поле класса;
            
            METHOD - метод класса;
            
            PARAMETER - параметры метода или конструктора
            
        @Retention описывает жизненный цикл Аннотации
            
            SOURCE - Аннотация видна в source коде, отбрасывается компилятором и уже в byte коде не видна;
            
            CLASS - Аннотация видна в byte коде, отбрасывается JVM во время выполнения программы;
            
            RUNTIME - Аннотация видна во время выполнения программы
            
            
            
            
            
            
            
            
            
            
            
            
            
